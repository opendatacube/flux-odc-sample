---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: jhub-standard-gp2
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
parameters:
  type: gp2
  fsType: ext4
provisioner: kubernetes.io/aws-ebs
reclaimPolicy: Delete
volumeBindingMode: Immediate
allowVolumeExpansion: true

---
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: hub
  namespace: sandbox
  annotations:
    fluxcd.io/ignore: false   # temporarily make Flux ignore a manifest if set to true
    fluxcd.io/automated: true  # automated deployment of new container images
    fluxcd.io/tag.scheduler: semver:*
    fluxcd.io/tag.worker: semver:*
spec:
  releaseName: hub
  chart:
    # Helm Charts: https://github.com/jupyterhub/helm-chart
    # Source Repository: https://github.com/jupyterhub/jupyterhub
    repository: https://jupyterhub.github.io/helm-chart/
    name: jupyterhub
    version: 0.8.2
  valueFileSecrets:
    - name: jhub
  values:
    hub:
      #cookieSecret - Injected by Flux
      imagePullPolicy: Always
      pdb:
        enabled: false
        minAvailable: 0
#      Injected by Flux - using secrets
#      annotations:
#        iam.amazonaws.com/role: ${role_name}
      extraConfig:
        spawner: |
          #!/usr/bin/env python3

          import json
          import os
          import sys
          import base64
          from kubernetes import client, config
          # install 'cognitojwt' packages to hub container - require to validate user claim.
          try:
            import cognitojwt
          except ImportError:
            import subprocess
            subprocess.call([sys.executable, "-m", "pip", "install", "wheel"])
            subprocess.call([sys.executable, "-m", "pip", "install", "--user", "cognitojwt[sync]"])
          finally:
            sys.path.append(os.path.expanduser('~') + "/.local/lib/python3.6/site-packages")
            import cognitojwt

          def enum(**enums):
            return type('Enum', (), enums)

          async def custom_options_form(self):
            self.log.info("logged in user: %s", self.user.name)
            # setup default profile_list for all users
            default_profile_list = [
              {
                'default': True,
                'display_name': 'AU: Standard environment',
                'description': 'Limited user, 2 Cores, 16G Memory Read access to database and files',
              },
            ]
            self.profile_list = default_profile_list

            cognito_user_groups = enum(
              DEVELOPMENT='dev-group',
              INTERNAL='internal-group',
              TRUSTED='trusted-group',
              DEFAULT='default-group',
              NONE='None'
            )

            try:
              # setup user_details and user_details
              user_details = ""
              access_token = ""
              auth_state = await self.user.get_auth_state()
              # self.log.info("auth_state: %s", json.dumps(auth_state, indent=4))
              if auth_state and "oauth_user" in auth_state:
                user_details = auth_state["oauth_user"]
              if auth_state and "access_token" in auth_state:
                access_token = auth_state["access_token"]
              # self.log.info("user[acces_token]: {}".format(access_token))

              verified_claims = cognitojwt.decode(
                access_token,
                os.getenv('AWS_DEFAULT_REGION', 'ap-southeast-2'),
                os.getenv('JUPYTERHUB_USERPOOL_ID'),
                testmode=False  # Enable token expiration check
              )
              user_group_info = []
              if verified_claims and "cognito:groups" in verified_claims:
                user_group_info = verified_claims["cognito:groups"]
              self.log.info("%s user group info: %s", self.user.name, (','.join(user_group_info)))

              # Use logic here to decide how to configure user profile_list if belongs to user-group
              if cognito_user_groups.DEVELOPMENT in user_group_info:
                # configure your profile_list for 'dev-group' user
                self.log.info("user belongs to {} cognito group".format(cognito_user_groups.DEVELOPMENT))
                dev_profile_list = [
                  {
                    'default': False,
                    'display_name': 'AU_DEV_SUDO: Standard environment with root user access',
                    'description': 'Root user, 2 Cores, 16G Memory Read access to database and files',
                    'kubespawner_override': {
                      'image': 'opendatacube/jupyterhub:0.2.11-unstable.8.g6c146b9_sudo'
                    }
                  },
                  {
                    'default': False,
                    'display_name': 'AU_DEV: Development environment',
                    'description': 'Jupyterhub environment with 4 Cores, 20G Memory Read access to database and files',
                    'kubespawner_override': {
                      'mem_guarantee': '20G',
                      'mem_limit': '20G',
                      'cpu_guarantee': 4,
                      'cpu_limit': 4,
                    },
                  },
                ]
                self.profile_list.extend(dev_profile_list)
              if cognito_user_groups.INTERNAL in user_group_info:
                # configure your profile_list for 'internal-group' user
                self.log.info("user belongs to {} cognito group".format(cognito_user_groups.INTERNAL))
              if cognito_user_groups.TRUSTED in user_group_info:
                # configure your profile_list for 'trusted-group' user
                self.log.info("user belongs to {} cognito group".format(cognito_user_groups.TRUSTED))
            except TypeError as err:
              self.log.error("Type error: {}".format(err))
            except cognitojwt.CognitoJWTException as err:
              self.log.error("Cliam verification issue: {}".format(err))
            except Exception as err:
              self.log.error("Unexpected error: {}".format(err))
            finally:
              # Let KubeSpawner inspect profile_list and decide what to return
              return self._options_form_default()

          # Set the log level by value or name.
          c.JupyterHub.log_level = 'DEBUG'

          # Enable debug-logging of the single-user server
          c.Spawner.debug = True

          # Enable debug-logging of the single-user server
          c.LocalProcessSpawner.debug = True
          c.Spawner.cmd = ['jupyter-labhub']

          # Override options_form
          c.KubeSpawner.options_form = custom_options_form
#      Injected by Flux - using secrets
#      extraEnv:
#        JUPYTERHUB_USERPOOL_ID: ${jhub_userpool_id}
#        AWS_DEFAULT_REGION: ${region}
#        OAUTH_CALLBACK_URL: ${jhub_userpool_callback_url}
#        OAUTH2_AUTHORIZE_URL: ${jhub_userpool_auth_url}
#        OAUTH2_TOKEN_URL: ${jhub_userpool_token_url}
#        OAUTH2_USERDATA_URL: ${jhub_userpool_userinfo_url}
    auth:
      type: custom
      custom:
        className: oauthenticator.generic.GenericOAuthenticator
        config:
          login_service: "email"
#          Injected by Flux - using secrets
#          client_id: ${jhub_auth_client_id}
#          client_secret: ${jhub_auth_client_secret}
    proxy:
      #secretToken - Injected by Flux
      nginx:
        image:
          name: quay.io/kubernetes-ingress-controller/nginx-ingress-controller
          tag: 0.27.0
      pdb:
        enabled: false
        minAvailable: 0
    scheduling:
      userScheduler:
        enabled: true
      podPriority:
        enabled: true
      userPlaceholder:
        enabled: false
        replicas: 2
      userPods:
        nodeAffinity:
          matchNodePurpose: require
    cull:
      enabled: true
      timeout: 3600
      every: 500
    singleuser:
#      extraAnnotations:
#        iam.amazonaws.com/role: ${role_name}
      defaultUrl: "/lab"
      memory:
        limit: 16G
      cpu:
        limit: 2
      cloudMetadata:
        enabled: true
      image:
        # Docker Hub: https://hub.docker.com/r/opendatacube/jupyterhub
        # Source Repository: https://github.com/opendatacube/jupyterhub
        name: opendatacube/jupyterhub
        tag: 0.2.13-unstable.1.gac2700f
      extraEnv:
        DB_PORT: "5432"
        #DB_PASSWORD - Injected by Flux
        #DB_USERNAME - Injected by Flux
        #DB_DATABASE - Injected by Flux
        #DB_HOSTNAME - Injected by Flux
        DATACUBE_CONFIG_PATH: "/conf/datacube.conf"
      storage:
        storageClass: jhub-standard-gp2
        extraVolumes:
          - name: notebooks
            emptyDir: {}
        extraVolumeMounts:
          - name: notebooks
            mountPath: /notebooks
      lifecycleHooks:
        postStart:
          exec:
            command:
              - "bash"
              - "-c"
              - |-
                git clone --depth 1 https://github.com/GeoscienceAustralia/dea-notebooks.git dea-notebooks
                rm -rf dea-notebooks/.github
                rm -rf dea-notebooks/Scientific_workflows
                rsync -avu dea-notebooks/ ~/
                rm -rf dea-notebooks
                rm LICENSE README.rst README.md |:
#    Injected by Flux - using secrets
#    ingress:
#      enabled: true
#      annotations:
#        kubernetes.io/tls-acme: "true"
#        kubernetes.io/ingress.class: alb
#        alb.ingress.kubernetes.io/healthcheck-path: /hub/login
#        alb.ingress.kubernetes.io/healthcheck-port: traffic-port
#        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
#        alb.ingress.kubernetes.io/scheme: internet-facing
#        alb.ingress.kubernetes.io/target-type: instance
#        alb.ingress.kubernetes.io/certificate-arn: ${cert_arn}
#      hosts:
#        - ${sandbox_host_name}
#      pathSuffix: "*"